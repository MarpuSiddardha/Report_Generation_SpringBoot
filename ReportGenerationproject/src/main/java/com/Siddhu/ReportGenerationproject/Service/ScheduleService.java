package com.Siddhu.ReportGenerationproject.Service;

import com.Siddhu.ReportGenerationproject.Entity.ReportMetadata;
import com.Siddhu.ReportGenerationproject.Entity.ScheduleConfig;
import com.Siddhu.ReportGenerationproject.Entity.SensorData;
import com.Siddhu.ReportGenerationproject.Repository.ScheduleConfigRepository;
import com.Siddhu.ReportGenerationproject.Repository.SensorDataRepository;
import com.Siddhu.ReportGenerationproject.Utils.ReportPdfGenerator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.Optional;

@Service
public class ScheduleService {

    private final ReportService reportService;

    private final ReportPdfGenerator reportPdfGenerator; // PDF generation utility

    private final SensorDataService sensorDataService;


    private static final Logger logger = LoggerFactory.getLogger(ScheduleService.class);

    private final ScheduleConfigRepository scheduleConfigRepository;

    private final SensorDataRepository sensorDataRepository;

    public ScheduleService(ReportService reportService, ScheduleConfigRepository scheduleConfigRepository, ReportPdfGenerator reportPdfGenerator,
                           SensorDataService sensorDataService, SensorDataRepository sensorDataRepository) {
        this.reportService = reportService;
        this.scheduleConfigRepository = scheduleConfigRepository;
        this.reportPdfGenerator = reportPdfGenerator;
        this.sensorDataService = sensorDataService;
        this.sensorDataRepository = sensorDataRepository;
    }

    public ScheduleConfig configureSchedule(String reportType, String scheduleInterval, LocalDateTime nextRun) {
        ScheduleConfig scheduleConfig = new ScheduleConfig();
        scheduleConfig.setReportType(reportType);
        scheduleConfig.setScheduleInterval(scheduleInterval);
        scheduleConfig.setNextRun(nextRun);

        return scheduleConfigRepository.save(scheduleConfig);
    }

    @Scheduled(cron = "${report.schedule.cron}")
    public void generateScheduledReports() {
        try {
            List<ScheduleConfig> schedules = scheduleConfigRepository.findAll();

            for (ScheduleConfig schedule : schedules) {

                String reportType = schedule.getReportType();

                List<SensorData> sensorDataList = reportService.fetchSensorData(reportType);

                if (sensorDataList.isEmpty()) {
                    System.err.println("No sensor data found for report type: " + reportType);
                    continue;
                }

                final String defaultDirectory = "C:\\Reports";
                File reportDir = new File(defaultDirectory);
                if (!reportDir.exists() && !reportDir.mkdirs()) {
                    throw new IOException("Failed to create reports directory.");
                }

                String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
                String filePath = defaultDirectory + "\\" + reportType + "AUTOGENERATED_Report_" + timestamp + ".pdf";

                ReportMetadata reportMetadata = new ReportMetadata();
                reportMetadata.setReportName(reportType + "AUTOGENERATED_Report");
                reportMetadata.setReportType(reportType);
                reportMetadata.setGeneratedTime(LocalDateTime.now());
                reportMetadata.setFilePath(filePath);

                reportService.createReport(reportType + "AUTOGENERATED_Report", reportType, filePath, reportType);

                System.out.println("Report generated: " + reportMetadata.getFilePath());
            }
        } catch (Exception e) {
            System.err.println("Error during report generation: " + e.getMessage());
        }
    }


    private boolean isReportGenerated(String reportType) {

        List<ReportMetadata> existingReports = reportService.viewReportByType(reportType);

        return existingReports.stream().anyMatch(report -> report.getGeneratedTime().toLocalDate().isEqual(LocalDateTime.now().toLocalDate()));
    }





//    public ScheduleConfig deleteSchedule(String reportType) {
//        Optional<ScheduleConfig> optionalScheduleConfig = scheduleConfigRepository.findByReportType(reportType);
//
//        if (optionalScheduleConfig.isEmpty()) {
//            throw new IllegalArgumentException("Schedule not found for report type: " + reportType);
//        }
//
//        ScheduleConfig scheduleConfig = optionalScheduleConfig.get();
//        scheduleConfigRepository.delete(scheduleConfig);
//        return scheduleConfig;
//    }



}
